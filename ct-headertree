#!/usr/bin/env python
from __future__ import print_function
from headerhunter import HeaderTree
import git_utils
import tree
import configargparse

def print_wrapper(data):
    """ Wrap the builtin print so that it can be passed to the tree.depth_first_traverse """
    print(data)


def depth_indicator_print(key, depth, indicator='--', strip_git_root=True):
    """ Print the filenames with a leading indicator to denote the depth of the file from the root """
    name = key
    if strip_git_root:
        name = git_utils.strip_git_root(key)
    print(indicator * depth + name)


class DotFormat:

    """ Print the include tree in graphviz dot format. """

    def __init__(self, tree_, strip_git_root=True):
        self.strip_git_root = strip_git_root
        for key in tree_:
            # TODO: Take care of the case where there are multiple top level
            # nodes
            if strip_git_root:
                self.name = git_utils.strip_git_root(key)
            else:
                self.name = key
        self._print_header()
        tree.depth_first_traverse(
            node=tree_,
            pre_traverse_function=self._print_node)
        self._print_footer()

    def _print_header(self):
        print('digraph "' + self.name + '" {')

    def _print_footer(self):
        print("}")

    def _print_node(self, key, value):
        name = key
        if self.strip_git_root:
            name = git_utils.strip_git_root(key)
        print('"' + name + '"')

        for child_key in value:
            child_name = child_key
            if self.strip_git_root:
                child_name = git_utils.strip_git_root(child_key)
            print('"' + name + '"->"' + child_name + '"')


class CostCounter:

    """ Show the cumulative cost and self cost of including the header files """

    def __init__(self, tree_, strip_git_root=True):
        self.strip_git_root = strip_git_root
        self.counter = [0]
        self.reverse_result = []
        tree.depth_first_traverse(
            node=tree_,
            pre_traverse_function=self._pre,
            post_traverse_function=self._post)
        self.print()

    def _pre(self, key, value, depth):
        self.counter.append(0)

    def _post(self, key, value, depth):
        last = self.counter.pop()
        self.counter[-1] += last + 1
        name = key
        if self.strip_git_root:
            name = git_utils.strip_git_root(key)

        # store cumulative includes and direct includes
        self.reverse_result.append(
            {'cumulative': last, 'self': len(value), 'depth': depth, 'name': name})

    def print(self):
        def righttreechars(child_index):
            return {1: u"\u2514\u2500"}.get(child_index, u"\u251c\u2500")

        def internaltreechars(child_index):
            return {0: u"  "}.get(child_index, u"\u2502 ")

        remaining_children = []
        for item in reversed(self.reverse_result):
            tree_structure = ""

            # Trim any no longer needed information from the remaining children
            if item['depth'] < len(remaining_children):
                remaining_children = remaining_children[:(item['depth'])]

            # Create the internal tree structure up to the grandparents
            if item['depth'] > 1:
                for child_index in remaining_children[:(item['depth'] - 1)]:
                    tree_structure += internaltreechars(child_index)

            # Add on the connector to the parent
            if item['depth'] > 0:
                tree_structure += righttreechars(
                    remaining_children[
                        item['depth'] -
                        1])

            print("{c:5d}".format(
                c=item['cumulative']) +
                "{d:3d}".format(
                d=item['self']) + " " + tree_structure +
                item['name'])

            # Since the child has now been drawn, reduce the parents count of
            # their remaining children (except for the topmost node which has
            # no parent)
            if remaining_children:
                remaining_children[-1] -= 1

            if item['self'] > 0:
                remaining_children.append(item['self'])


if __name__ == '__main__':
    cap = configargparse.getArgumentParser()
    cap.add("filename", help="File to start tracing headers from")
    cap.add("-c", "--config", is_config_file=True, help="config file path")
    ht = HeaderTree()

    myargs = cap.parse_known_args()

    if myargs[0].verbose >= 1:
        print(myargs[0])
    if myargs[0].verbose >= 2:
        cap.print_values()

    inctree = ht.process(myargs[0].filename)
#    tree.depth_first_traverse(node=inctree,post_traverse_function=print_wrapper)
#    tree.depth_first_traverse(node=inctree,pre_traverse_function=depth_indicator_print)

#    df = DotFormat(inctree)
#    print()

    cc = CostCounter(inctree)
