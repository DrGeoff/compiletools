#!/usr/bin/env python
from __future__ import print_function
from collections import defaultdict
import inspect
import math
from headerhunter import HeaderTree
import git_utils
import utils
import tree
import configargparse


class FlatStyle:
    """ Print a newline delimited list of header files """

    def __init__(self, tree_, strip_git_root=True):
        self.strip_git_root = strip_git_root
        tree.depth_first_traverse(
            node=tree_,
            pre_traverse_function=self.print_wrapper)

    def print_wrapper(self, key):
        """ Wrap the builtin print so that it can be passed to the tree.depth_first_traverse """
        name = key
        if self.strip_git_root:
            name = git_utils.strip_git_root(key)
        print(name)


class DepthStyle:

    """ Print the include tree with some sort of indicator of depth """

    def __init__(self, tree_, strip_git_root=True, indicator="--"):
        self.strip_git_root = strip_git_root
        self.indicator = indicator
        tree.depth_first_traverse(
            node=tree_,
            pre_traverse_function=self.depth_indicator_print)

    def depth_indicator_print(self, key, depth):
        """ Print the filenames with a leading indicator to denote the depth of the file from the root """
        name = key
        if self.strip_git_root:
            name = git_utils.strip_git_root(key)
        print(self.indicator * depth + name)


class DotStyle:

    """ Print the include tree in graphviz dot format. """

    def __init__(self, tree_, strip_git_root=True):
        self.strip_git_root = strip_git_root
        for key in tree_:
            # TODO: Take care of the case where there are multiple top level
            # nodes
            if strip_git_root:
                self.name = git_utils.strip_git_root(key)
            else:
                self.name = key
        self._print_header()
        tree.depth_first_traverse(
            node=tree_,
            pre_traverse_function=self._print_node)
        self._print_footer()

    def _print_header(self):
        print('digraph "' + self.name + '" {')

    def _print_footer(self):
        print("}")

    def _print_node(self, key, value):
        name = key
        if self.strip_git_root:
            name = git_utils.strip_git_root(key)
        print('"' + name + '"')

        for child_key in value:
            child_name = child_key
            if self.strip_git_root:
                child_name = git_utils.strip_git_root(child_key)
            print('"' + name + '"->"' + child_name + '"')


class TreeStyle:

    """ Show the cumulative cost and self cost of including the header files """

    def __init__(self, tree_, strip_git_root=True, verbose=0):
        self.strip_git_root = strip_git_root
        self.verbose = verbose
        self.max_cumulative = 0  # Used to figure out the number of digits to leave space for
        self.max_self = 0        # Used to figure out the number of digits to leave space for
        self.max_duplicates = 0  # Used to figure out the number of digits to leave space for
        self.counter = [0]       # Counter will be used as a stack
        self.reverse_result = []  # The output in reverse order
        # Count the number of times a given header is included across all
        # branches of the include tree
        self.duplicates = defaultdict(int)
        tree.depth_first_traverse(
            node=tree_,
            pre_traverse_function=self._pre,
            post_traverse_function=self._post)
        self.print()

    def _pre(self, key):
        self.counter.append(0)
        self.duplicates[key] += 1

    def _post(self, key, value, depth):
        last = self.counter.pop()
        self.counter[-1] += last + 1
        name = key
        if self.strip_git_root:
            name = git_utils.strip_git_root(key)

        if last > self.max_cumulative:
            self.max_cumulative = last

        if len(value) > self.max_self:
            self.max_self = len(value)

        if self.duplicates[key] > self.max_duplicates:
            self.max_duplicates = self.duplicates[key]

        # store cumulative includes and direct includes
        self.reverse_result.append({'cumulative': last, 'self': len(
            value), 'depth': depth, 'name': name, 'key': key})

    def print(self):
        if self.verbose >= 1:
            print(
                "First column is the cumulative count of headers (recursively) included by the filename.")
            print(
                "Second column is the self count.  That is, the headers directly included by the filename.")
            print(
                "Third column is the number of times the file is duplicated in this tree.")

        def righttreechars(child_index):
            return {1: u"\u2514\u2500"}.get(child_index, u"\u251c\u2500")

        def internaltreechars(child_index):
            return {0: u"  "}.get(child_index, u"\u2502 ")

        cumulative_digits = 1 + int(math.floor(math.log10(self.max_cumulative)))
        cumulative_format_str = "{c:" + str(cumulative_digits) + "d}"
        self_digits = 1 + int(math.floor(math.log10(self.max_self)))
        self_format_str = "{d:" + str(self_digits) + "d}"
        duplicates_digits = 1 + int(math.floor(math.log10(self.max_duplicates)))
        duplicates_format_str = "{p:" + str(duplicates_digits) + "d}"

        remaining_children = []
        for item in reversed(self.reverse_result):
            tree_structure = ""

            # Trim any no longer needed information from the remaining children
            if item['depth'] < len(remaining_children):
                remaining_children = remaining_children[:(item['depth'])]

            # Create the internal tree structure up to the grandparents
            if item['depth'] > 1:
                for child_index in remaining_children[:(item['depth'] - 1)]:
                    tree_structure += internaltreechars(child_index)

            # Add on the connector to the parent
            if item['depth'] > 0:
                tree_structure += righttreechars(
                    remaining_children[
                        item['depth'] -
                        1])
            print(
                cumulative_format_str.format(
                    c=item['cumulative']) +
                " " +
                self_format_str.format(
                    d=item['self']) +
                " " +
                duplicates_format_str.format(
                    p=self.duplicates[
                        item['key']]) +
                " " +
                tree_structure +
                item['name'])

            # Since the child has now been drawn, reduce the parents count of
            # their remaining children (except for the topmost node which has
            # no parent)
            if remaining_children:
                remaining_children[-1] -= 1

            if item['self'] > 0:
                remaining_children.append(item['self'])


if __name__ == '__main__':
    cap = configargparse.getArgumentParser(
        description='Create a tree of header dependencies starting at a given C/C++ file. ',
        formatter_class=configargparse.DefaultsRawFormatter)
    cap.add("filename", help="File to start tracing headers from")
    cap.add("-c", "--config", is_config_file=True, help="config file path")

    # Figure out what style classes are available and add them to the command
    # line options
    styles = [st[:-5] for st in dict(globals()) if st.endswith('Style')]
    cap.add(
        '--style',
        choices=styles,
        default='Tree',
        help="Output formatting style")

    utils.add_boolean_argument(
        cap,
        "shorten",
        'strip_git_root',
        default=True,
        help="Strip the git root from the filenames")

    # Side effect of creating the HeaderTree is that it adds options to the
    # command line arguments
    ht = HeaderTree()

    myargs = cap.parse_known_args()
    if myargs[0].verbose >= 2:
        print(myargs[0])
    if myargs[0].verbose >= 3:
        cap.print_values()

    # Create the headertree then print it in the appropriate style
    inctree = ht.process(myargs[0].filename)
    style_class = globals()[myargs[0].style + 'Style']

    # Build up the appropriate arguments to pass to the initialization of the style object
    # For each argument given on the command line, check if it matches one for
    # the __init__
    kwargs = {}
    function_args = inspect.getargspec(style_class.__init__).args
    for key, value in vars(myargs[0]).items():
        if key in function_args:
            kwargs[key] = value

    # Construct an instance of the style class which will print the header
    # tree as a side effect
    style_object = style_class(inctree, **kwargs)
