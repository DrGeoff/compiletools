#!/usr/bin/env python
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import sys

if sys.version_info[0] < 3:
    import codecs
from collections import defaultdict
from collections import Counter
import inspect
import math
import ct.wrappedos
from ct.hunter import HeaderTree
import ct.git_utils as git_utils
import ct.utils as utils
import ct.tree as tree
import configargparse


class FlatStyle(object):
    """ Print a newline delimited list of header files """

    def __init__(self, tree_, strip_git_root=True):
        self.strip_git_root = strip_git_root
        tree.depth_first_traverse(
            node=tree_,
            pre_traverse_function=self.print_wrapper)

    def print_wrapper(self, key):
        """ Wrap the builtin print so that it can be passed to the tree.depth_first_traverse """
        name = key
        if self.strip_git_root:
            name = git_utils.strip_git_root(key)
        print(name)


class DepthStyle(object):
    """ Print the include tree with some sort of indicator of depth """

    def __init__(self, tree_, strip_git_root=True, indicator="--"):
        self.strip_git_root = strip_git_root
        self.indicator = indicator
        tree.depth_first_traverse(
            node=tree_,
            pre_traverse_function=self.depth_indicator_print)

    def depth_indicator_print(self, key, depth):
        """ Print the filenames with a leading indicator to denote the depth of the file from the root """
        name = key
        if self.strip_git_root:
            name = git_utils.strip_git_root(key)
        print(self.indicator * depth + name)


class DotStyle(object):
    """ Print the include tree in graphviz dot format. """

    def __init__(self, tree_, strip_git_root=True):
        self.strip_git_root = strip_git_root
        for key in tree_:
            # TODO: Take care of the case where there are multiple top level
            # nodes
            if strip_git_root:
                self.name = git_utils.strip_git_root(key)
            else:
                self.name = key
        self._print_header()
        tree.depth_first_traverse(
            node=tree_,
            pre_traverse_function=self._print_node)
        self._print_footer()

    def _print_header(self):
        print('digraph "' + self.name + '" {')

    @staticmethod
    def _print_footer():
        print("}")

    def _print_node(self, key, value):
        name = key
        if self.strip_git_root:
            name = git_utils.strip_git_root(key)
        print('"' + name + '"')

        for child_key in value:
            child_name = child_key
            if self.strip_git_root:
                child_name = git_utils.strip_git_root(child_key)
            print('"' + name + '"->"' + child_name + '"')


class TreeStyle(object):
    """ Show the cumulative cost and self cost of including the header files """

    # TODO: There are now four different statistics that TreeStyle calculates and
    #       we can easily imagine more.  And by embedding the statistics in here
    #       they are unavailable to DotStyle.  We need to separate the output
    #       formatting style from the calculated statistics. Also the statistics
    #       should be command line settable so that you only get what
    #       you want

    def __init__(self, tree_, strip_git_root=True, verbose=0):
        self.strip_git_root = strip_git_root
        self.verbose = verbose

        # The various max_* variables are used to figure out the number of
        # digits to leave space for
        self.max_cumulative = 1
        self.max_self = 1
        self.max_duplicates = 1
        self.max_parents = 1

        self.counter = [0]  # Counter will be used as a stack
        # List of all parents leading to the current node.  Used as a stack.
        self.parent_stack = []
        # A dict mapping a file to the set of parents of that file
        self.parents = defaultdict(set)
        self.reverse_result = []  # The output in reverse order
        # Count the number of times a given header is included across all
        # branches of the include tree
        self.duplicates = Counter()

        # Now traverse the tree and print out the result
        tree.depth_first_traverse(
            node=tree_,
            pre_traverse_function=self._pre,
            post_traverse_function=self._post)
        self.print()

    def _pre(self, key):
        self.counter.append(0)
        self.duplicates[key] += 1
        self.parent_stack.append(key)

    def _post(self, key, value, depth):
        self.parent_stack.pop()  # pop the current file off the stack
        try:
            # push the immediate parent into the set of parents of the file
            self.parents[key].add(self.parent_stack[-1])
        except IndexError:
            pass
        last = self.counter.pop()
        self.counter[-1] += last + 1
        name = key
        if self.strip_git_root:
            name = git_utils.strip_git_root(key)
        self.max_cumulative = max(self.max_cumulative, self.counter[-1])
        self.max_self = max(self.max_self, len(value))
        self.max_duplicates = max(self.max_duplicates, self.duplicates[key])
        self.max_parents = max(self.max_parents, len(self.parents[key]))

        # store cumulative includes and direct includes
        self.reverse_result.append({'cumulative': last, 'self': len(
            value), 'depth': depth, 'name': name, 'key': key})

    def print(self):
        if self.verbose >= 1:
            print(
                "First column is the cumulative count of headers (recursively) included by the filename.")
            print(
                "Second column is the self count.  That is, the headers directly included by the filename.")
            print(
                "Third column is the number of times the file is duplicated in this tree.")
            print(
                "Fourth column is the number of unique parents the file has.")

        def _righttreechars(child_index):
            return {1: u"\u2514\u2500"}.get(child_index, u"\u251c\u2500")

        def _internaltreechars(child_index):
            return {0: u"  "}.get(child_index, u"\u2502 ")

        def _digits_str(max_value):
            """ How many digits are in the number when represented in base 10. Return as a string. """
            return str(1 + int(math.floor(math.log10(max_value))))

        cumulative_format_str = "{c:" + _digits_str(self.max_cumulative) + "d}"
        self_format_str = "{s:" + _digits_str(self.max_self) + "d}"
        duplicates_format_str = "{d:" + _digits_str(self.max_duplicates) + "d}"
        parents_format_str = "{p:" + _digits_str(self.max_parents) + "d}"

        remaining_children = []
        for item in reversed(self.reverse_result):
            tree_structure = ""

            # Trim any no longer needed information from the remaining children
            if item['depth'] < len(remaining_children):
                remaining_children = remaining_children[:(item['depth'])]

            # Create the internal tree structure up to the grandparents
            if item['depth'] > 1:
                for child_index in remaining_children[:(item['depth'] - 1)]:
                    tree_structure += _internaltreechars(child_index)

            # Add on the connector to the parent
            if item['depth'] > 0:
                tree_structure += _righttreechars(
                    remaining_children[
                        item['depth'] -
                        1])
            print(
                cumulative_format_str.format(
                    c=item['cumulative']) +
                " " +
                self_format_str.format(
                    s=item['self']) +
                " " +
                duplicates_format_str.format(
                    d=self.duplicates[
                        item['key']]) +
                " " +
                parents_format_str.format(
                    p=len(self.parents[
                              item['key']])) +
                " " +
                tree_structure +
                item['name'])

            # Since the child has now been drawn, reduce the parents count of
            # their remaining children (except for the topmost node which has
            # no parent)
            if remaining_children:
                remaining_children[-1] -= 1

            if item['self'] > 0:
                remaining_children.append(item['self'])


if __name__ == '__main__':
    # Python 3 stdout accepts unicode by default
    # So we only need to force python 2 stdout to accept unicode
    if sys.version_info[0] < 3:
        UTF8Writer = codecs.getwriter('utf8')
        sys.stdout = UTF8Writer(sys.stdout)
    config_files = utils.config_files_from_variant()
    cap = configargparse.getArgumentParser(
        description='Create a tree of header dependencies starting at a given C/C++ file. ',
        formatter_class=configargparse.DefaultsRawFormatter,
        default_config_files=config_files)
    cap.add(
        "-c",
        "--config",
        is_config_file=True,
        help="Manually specify the config file path if you want to override the variant default")
    cap.add("filename", help="File to start tracing headers from", nargs='+')

    # Figure out what style classes are available and add them to the command
    # line options
    styles = [st[:-5] for st in dict(globals()) if st.endswith('Style')]
    cap.add(
        '--style',
        choices=styles,
        default='Tree',
        help="Output formatting style")

    utils.add_boolean_argument(
        cap,
        "shorten",
        'strip_git_root',
        default=True,
        help="Strip the git root from the filenames")

    # Side effect of creating the HeaderTree is that it adds options to the
    # command line arguments
    ht = HeaderTree()

    myargs = cap.parse_known_args()
    utils.verbose_print_args(myargs[0])

    if not ct.wrappedos.isfile(myargs[0].filename[0]):
        sys.stderr.write(
            "The supplied filename ({0}) isn't a file.  Did you spell it correctly?  Another possible reason is that you didn't supply a filename and that configargparse has picked an unused positional argument from the config file.\n".format(
                myargs[0].filename[0]))
        exit(1)

    # Create the headertree then print it in the appropriate style
    inctree = ht.generatetree(myargs[0].filename[0])
    style_class = globals()[myargs[0].style + 'Style']

    # Build up the appropriate arguments to pass to the initialization of the style object
    # For each argument given on the command line, check if it matches one for
    # the __init__
    kwargs = {}
    function_args = inspect.getargspec(style_class.__init__).args
    for key, value in list(vars(myargs[0]).items()):
        if key in function_args:
            kwargs[key] = value

    # Construct an instance of the style class which will print the header
    # tree as a side effect
    try:
        style_object = style_class(inctree, **kwargs)
    except IOError:
        pass
