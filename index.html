<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>

  <title>compiletools -- Tools to make compiling C/C++ projects easy </title>

  <style type="text/css">
    body p {
      margin-top: 1.0em;
      background-color: #ffffff;
      font-family: "Helvetica,Arial,FreeSans";
      color: #000;
    }
    #container {
      margin: 0 auto;
      width: 700px;
    }
    h1 { font-size: 3.8em; color: #111111; margin-bottom: 3px; font-family:"Helvetica,Arial,FreeSans"; }
    h1 .small { font-size: 0.4em; color: #111111; font-family:"Helvetica,Arial,FreeSans"; }
    h1 a { text-decoration: none; font-family:"Helvetica,Arial,FreeSans"; }
    h2 { font-size: 1.5em; color: #111111; font-family:"Helvetica,Arial,FreeSans"; }
    h3 { text-align: center; color: #111111; font-family:"Helvetica,Arial,FreeSans"; }
    a { color: #111111; }
    .description { font-size: 1.2em; margin-bottom: 30px; margin-top: 30px; font-style: italic;
            color:#000; font-family:"Helvetica,Arial,FreeSans" }
    .download { float: right; }
    pre { background: #ddd; color: #000; padding: 15px;}
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .footer { text-align:center; padding-top:30px; font-style: italic; color:#000; }
  </style>
</head>

<body>
  <a href="http://github.com/Zomojo/compiletools"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>

  <div id="container">

    <div class="download">
      <a href="http://github.com/Zomojo/compiletools/zipball/master">
        <img border="0" width="90" src="http://github.com/images/modules/download/zip.png"></a>
      <a href="http://github.com/Zomojo/compiletools/tarball/master">
        <img border="0" width="90" src="http://github.com/images/modules/download/tar.png"></a>
    </div>

    <h1><a href="http://github.com/Zomojo/compiletools">compiletools</a></h1>

    <div class="description">
    The various ct-* tools exist to build C/C++ executables with almost no
    configuration. For example, to build a C or C++ program, type
    <pre>ct-cake --auto</pre>
    ct-cake will try to determine the correct source files to generate executables
    from and also determine the tests to build and run. It works by spidering over
    the source code to determine what implementation files to build, what libraries to
    link against and what compiler flags to set. Only build what you need, and
    throw out your Makefiles.
    </div>
        
    
    <h2>Authors</h2>
<p>Zomojo Pty, Ltd. - Geoff Ericksson (geoff@zomojo.com)
<br/>
<br/>      </p>


    <h2>Download</h2>
    <p>
      You can download this project from
      <a href="https://github.com/Zomojo/compiletools/releases">releases</a>
    </p>
    <p>You can also clone the project with <a href="http://git-scm.com">Git</a>
      by running:
      <pre>$ git clone git://github.com/Zomojo/compiletools</pre>
    </p>
    <p>Or pip install using
    <pre>pip install compiletools</pre> 

<h2>Dependencies</h2>
A relatively recent version of python is required.  python 2.7 and above should work.
If you are running compiletools from a cloned git repo, you will need to install the following python modules: 
setuptools, configargparse, appdirs and psutil. To install these on a recent Fedora run
<pre>sudo dnf install python2-setuptools python2-configargparse python2-appdirs python2-psutil</pre>
or if you prefer to use python3 
<pre>sudo dnf install python3-setuptools python3-configargparse python3-appdirs python3-psutil</pre>

<h2>Getting Started</h2>

<p>
The ct-* tools can run from the cloned git repository. Simply edit your PATH variable to include the repo. For example, if you cloned into your home directory then 
<pre>PATH=~/compiletools:$PATH</pre>
</p>


Now, copy this source code into a file called example.cpp:

<pre>
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;iostream&gt;
//#LDFLAGS=-pthread -lrt

static void pclock(const char *msg, clockid_t cid)
{
   struct timespec ts;
   printf("%s", msg);
   if (clock_gettime(cid, &ts) == -1)
       perror("clock_gettime");
   printf("%4ld.%03ld\n", ts.tv_sec, ts.tv_nsec / 1000000);
}
    
    
int main()
{
    clockid_t cid;
    pthread_t pt = pthread_self();
        
    if (pthread_getcpuclockid(pt, &cid))
        perror("getcpuclockid failed");
        
    pclock("the clock is", cid);
    return 0;
}
</pre>

Compile it and run it using this command:

<pre>
$ ct-cake --auto && ./bin/example
</pre>
which will produce output similar to 
<pre>
make -s -j 3 -f /home/geoff/tmp/bin/gcc.debug/Makefile build
... /home/geoff/tmp/example.cpp
... /home/geoff/tmp/bin/gcc.debug/example
bin/example
the clock is   0.001
</pre>

<p>
What occured was ct-cake searched all the files to find a source file containing the word "main".
It then searched the source file to extract the link flags that are annotated in the source code, so it 
wasn't necessary to supply them at the command-line. compiletools is based on the principle that 
the source code and the build settings are kept together.  This will increase the likelihood of 
keeping the compile flags in sync with the header includes. 
A Makefile was created that expressed the required build and then make was called. Finally the execuatable
was executed.
</p>


<h2>Overview</h2>

<p>
The compiletools project provides a variety of tools for building C/C++ projects and for exploring 
code dependencies. ct-cake is the Swiss army knife of build tools that combines many of the 
compiletools into one uber-tool. For many C/C++ projects you can compile simply using
<pre>
ct-cake --auto
</pre>
The --auto flag tells ct-cake to search for files that will be the "main" file.  
From that set of files, ct-cake then uses the header includes to
determine what implementation (cpp) files are also required to be built and linked 
into the final executable/s.
</p>

<p>

Cake works off the same principles as Ruby on Rails. It will make your life
easy if you don't arbitrarily name things. The main rules are:

</p>
<p>

<ol>
   <li>ct-cake only builds C and C++. Everything can be done just fine with
   other tools, so there's no point reinventing them. Anyway, it's easy to
   embed cake into other toolchains, see the last section.</li>

   <li>All binaries end up in the bin directory, with the same base name as
   their source filename. You can override this at the command-line, but it's
   against the spirit of the tool.</li>

   <li>The implementation file for point.hpp should be called point.cpp. This
   is so ct-cake can compile it and recursively hunt down its dependencies.</li>

   <li>If a header or implementation file will not work without being linked
   with a certain flag, add a //#LDFLAGS=myflag directly to the source code.</li>

   <li>Likewise, if a special compiler option is needed, use //#CXXFLAGS=myflag.</li>

   <li>Minimise the use of "-I" include flags. They make it hard not only
   for cake to generate dependencies, but also autocomplete tools like Eclipse and
   ctags. You can avoid -I flags by structuring your code in the same way you
   refer to paths in your source code. 
   </li>

   <li>Currently only varieties of Linux are actively supported because that's
   what the compiletools developers have easy access to. That said, it stands
   a good chance of working on *BSD and macOS. We are interested in receiving
   patches for other platforms including Windows.
   </li>
</ol>

</p>
<p>
ct-cake works off a "pull" philosophy of building, unlike the "push" model
of most build processes. Often, there is the monolithic build script that
rebuilds everything. Users iterate over changing a file, relinking everything
and then rerunning their binary. A hierarchy of libraries is built up and
then linked in to the final executables. All of this takes a lot of time,
particularly for C++.

</p>
<p>

With ct-cake, you only pull in what is strictly necessary to what you need to run
right now. Say, you are testing a particular tool in a large project, with
a large base of 2000 library files for string handling, sockets, etc. There
is simply no make file. You might want to create a build.sh for regression
testing, but it's not essential.

</p>
<p>

The basic workflow is to simply type:
<pre>
ct-cake --auto
</pre>
If there are multiple executables that --auto finds and you only want to build one specific one:
<pre>
   ct-cake path/to/src/app.cpp
</pre>

</p>
<p>

Only the library cpp files that are needed, directly, or indictly to create
./bin/app are actually compiled. If you don't #include anything that refers
to a library file, you don't pay for it. Also, only the link options that
are strictly needed to generate the app are included. Its possible to do in
make files, but such fine-level granularity is rarely set up in practice,
because its too error-prone to do manually, or with recursive make goodness.

</p>

<h2>How it Works</h2>

<p>
ct-cake generates the header dependencies for the "main.cpp"
file you specify at the command line by either examining the "#include" 
lines in the source code or by executing "gcc -MM -MF". 
For each header file found in the source file, it looks for
an underlying implementation (cpp) file with the same name, and adds that 
implementation file to the build. 
ct-cake also reads the first 8KB of each file for special comments
that indicate needed link and compile flags.  Then it recurses through the
dependencies of the cpp file, and uses this spidering to generate complete
dependency information for the application. A Makefile is generated and 
finally it calls make.

</p>

<h2>Magic Comments</h2>

<p>

ct-ake works very differently to other build systems, which specify a hierarchy
of link flags and compile options, because ct-cake ties the compiler flags
directly to the source code. If you have compress.hpp that requires "-lzip"
on the link line, add the following comment in the first 8KB of the header file:

<pre>
    //#LDFLAGS=-lzip
</pre>

</p>
<p>

Whenever the header is included (either directly or indirectly), the -lzip
will be automatically added to the link step. If you stop using the header,
for a particular executable, cake will figure that out and not link against it.

</p>
<p>

If you want to compile a cpp file with a particular optimization enabled,
add, say:

<pre>
    //#CXXFLAGS=-fstrict-aliasing
</pre>

Because the code and build flags are defined so close to each other, its
much easier to tweak the compilation locally.

</p>

<h2>Performance</h2>

<p>
Because ct-cake internally generates a makefile to build the C++ file, cake is
about as fast as a handrolled Makefile that uses the same lazily generated
dependencies. A typical project takes 0.04 seconds to build if nothing is
out of date, versus 2 seconds for, say, Boost.Build.

</p>
<p>

ct-cake also eliminates the redundant generation of static archive files that
a more hierarchical build process would generate as intermediaries, saving
the cost of running 'ar'.

</p>
<p>
Note that ct-cake doesn't build all cpp files that you have checked out, only those
strictly needed to build your particular binary, so you only pay for what
you use. This difference alone should see a large improvement on most
projects, especially for incremental rebuilds.

</p>


<h2>Cake configuration</h2>

<p>
The compiletools programs require <i>almost</i> no configuration. However, it is still
useful to have some shortcut build templates such as 'release',
'profile' etc.
</p>

<p>
Config files for the ct-* applications are programmatically located using 
python-appdirs, which on linux is a wrapper around the XDG specification. 
Thus default locations are /etc/xdb/ct/ and $HOME/.config/ct/.  
Configuration parsing is done using python-configargparse which automatically 
handles environment variables, command line arguments, system configs
and user configs.  

Specifically, the config files are searched for in the following 
locations (from lowest to highest priority):
<ul>
    <li> same path as exe,</li>
    <li> system config (XDG compliant, so usually /etc/xdg/ct)</li>
    <li> python virtual environment system configs (${python-site-packages}/etc/xdg/ct)</li>
    <li> user config   (XDG compliant, so usually ~/.config/ct)</li>
</ul>

The ct-* applications are aware of two levels of configs.  
There is a base level ct.conf that contains the basic variables that apply no  
matter what variant (i.e, debug/release/etc) is being built. 

The second layer of config files are the variant configs that contain the 
details for the debug/release/etc.  The variant names are simply a config file 
name but without the .conf. There are also variant aliases to make for less 
typing. So --variant=debug looks up the variant alias (specified in ct.conf) 
and notices that "debug" really means "gcc.debug".  So the config file that 
gets opened is "gcc.debug.conf".  If any config value is specified in more 
than one way then the following hierarchy is used

<pre>
    command line > environment variables > config file values > defaults
</pre>

An example /etc/xdg/ct/ file looks as follows:

<pre>
ID=GNU
CC=gcc
CXX=g++
LD=g++
CFLAGS=-fPIC -g -Wall -O3 -DNDEBUG -finline-functions -Wno-inline
CXXFLAGS=-std=c++11 -fPIC -g -Wall -fdiagnostics-color=auto -O3 -DNDEBUG -finline-functions -Wno-inline
LDFLAGS=-fPIC -Wall -Werror -Xlinker --build-id
TESTPREFIX=timeout 300 valgrind --quiet --error-exitcode=1
</pre>

<p>
CXXFLAGS lists the flags appended to each compilation job. The value in /etc/xdg/ct/gcc.debug.conf
is completely overridden by the environment variable, which is completely overridden by
the command-line argument --CXXFLAGS=. Likewise, LDFLAGS sets the default options used
for linking.
</p>

<p>
TESTPREFIX specifies a command prefix to place in front of unit test runs. This should
ideally be a tool like valgrind, gdb or purify that can be configured to execute the app and
return a non-zero exit code on any failure.
</p>


<h2>Build variants</h2>
A variant is a configuration file that specifies various configurable settings like the compiler 
and compiler flags. Common variants are "debug" and "release".  
Build variants are used by specifying the variant name at the command-line as follows:

<pre>
    $ ct-cake --variant=release a.cpp && ./bin/a
</pre>

<h2>Unit Tests</h2>

<p>
ct-cake integrates with unit tests in a fairly simple (and perhaps simplistic) way.
</p>

ct-cake allows you to specify multiple build targets on each line,
so the following is valid and useful:

<pre>
     $ ct-cake utilities/*.cpp    # builds all apps and places them under bin/
</pre>

Unit tests are executables that are generated, that create an additional
build step. They must run and return an exit code of 0 as part of the build
process. To specify that executables are unit tests, use the --tests flag.

<pre>
     $ ct-cake utilities/*.cpp --tests tests/*.cpp
</pre>

If the <tt>TESTPREFIX</tt> variable is set, you can automatically check
all unit tests with a code purifying tool. For example:

<pre>
export TESTPREFIX="valgrind --quiet --error-exitcode=1"
</pre>

will cause all unit tests to only pass if they run through valgrind with no
memory errors.

<h2>Putting it all together - a typical build setup</h2>

<p>
For most simple projects, a build.sh script that looks like the
following is quite useful. You can simply add more cpp to 
the apps directory to generate more tools from the project,
or add test scripts to the regression directory to improve
test coverage.
</p>

<p>
Code generation steps can be added at the beginning of
the build.sh, before cake runs.
</p>

<pre>
#!/bin/bash

set -e

ct-cake apps/*.cpp --tests tests/*.cpp "$@"

</pre>

<p>The special <tt>"$@"</tt> marker is the recommended way
of forwarding arguments to an application. You can then
run the build script like this:</p>

<pre>
    $ ./build.sh --variant=release
</pre>

or:

<pre>
    $ ./build.sh --variant=release --append-CXXFLAGS=-DSPECIALMODE
</pre>


</div>
  
</body>
</html>
