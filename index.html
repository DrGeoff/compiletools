<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>

  <title>compiletools -- Tools to make compiling C/C++ projects easy </title>

  <style type="text/css">
    body p {
      margin-top: 1.0em;
      background-color: #ffffff;
      font-family: "Helvetica,Arial,FreeSans";
      color: #000;
    }
    #container {
      margin: 0 auto;
      width: 700px;
    }
    h1 { font-size: 3.8em; color: #111111; margin-bottom: 3px; font-family:"Helvetica,Arial,FreeSans"; }
    h1 .small { font-size: 0.4em; color: #111111; font-family:"Helvetica,Arial,FreeSans"; }
    h1 a { text-decoration: none; font-family:"Helvetica,Arial,FreeSans"; }
    h2 { font-size: 1.5em; color: #111111; font-family:"Helvetica,Arial,FreeSans"; }
    h3 { text-align: center; color: #111111; font-family:"Helvetica,Arial,FreeSans"; }
    a { color: #111111; }
    .description { font-size: 1.2em; margin-bottom: 30px; margin-top: 30px; font-style: italic;
            color:#000; font-family:"Helvetica,Arial,FreeSans" }
    .download { float: right; }
    pre { background: #ddd; color: #000; padding: 15px;}
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .footer { text-align:center; padding-top:30px; font-style: italic; color:#000; }
  </style>
</head>

<body>
  <a href="http://github.com/Zomojo/compiletools"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>

  <div id="container">

    <div class="download">
      <a href="http://github.com/Zomojo/compiletools/zipball/master">
        <img border="0" width="90" src="http://github.com/images/modules/download/zip.png"></a>
      <a href="http://github.com/Zomojo/compiletools/tarball/master">
        <img border="0" width="90" src="http://github.com/images/modules/download/tar.png"></a>
    </div>

    <h1><a href="http://github.com/Zomojo/compiletools">compiletools</a></h1>

    <div class="description">
    The various ct-* tools exist to build C/C++ executables with almost no
    configuration. For example, to build a C or C++ program, type
    <pre>ct-cake --auto</pre>
    ct-cake will try to determine the correct source files to generate executables
    from and also determine the tests to build and run. It works by spidering over
    the source code to determine what implementation files to build, what libraries to
    link against and what compiler flags to set. Only build what you need, and
    throw out your Makefiles.
    </div>
        
    
    <h2>Authors</h2>
<p>Zomojo Pty, Ltd. - Geoff Ericksson (geoff@zomojo.com)
<br/>
<br/>      </p>


    <h2>Download</h2>
    <p>
      You can download this project from
      <a href="https://github.com/Zomojo/compiletools/releases">releases</a>
    </p>
    <p>You can also clone the project with <a href="http://git-scm.com">Git</a>
      by running:
      <pre>$ git clone git://github.com/Zomojo/compiletools</pre>
    </p>
    <p>Or pip install using
    <pre>pip install compiletools</pre> 

<h2>Dependencies</h2>
A relatively recent version of python is required.  python 2.7 and above should work.
If you are running compiletools from a cloned git repo, you will need to install the following python modules: 
setuptools, configargparse, appdirs and psutil. To install these on a recent Fedora run
<pre>sudo dnf install python2-setuptools python2-configargparse python2-appdirs python2-psutil</pre>
or if you prefer to use python3 
<pre>sudo dnf install python3-setuptools python3-configargparse python3-appdirs python3-psutil</pre>

<h2>Getting Started</h2>

<p>
The ct-* tools can run from the cloned git repository. Simply edit your PATH variable to include the repo. For example, if you cloned into your home directory then 
<pre>PATH=~/compiletools:$PATH</pre>
</p>


Now, copy this source code into a file called example.cpp:

<pre>
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;iostream&gt;
//#LDFLAGS=-pthread -lrt

static void pclock(const char *msg, clockid_t cid)
{
   struct timespec ts;
   printf("%s", msg);
   if (clock_gettime(cid, &ts) == -1)
       perror("clock_gettime");
   printf("%4ld.%03ld\n", ts.tv_sec, ts.tv_nsec / 1000000);
}
    
    
int main()
{
    clockid_t cid;
    pthread_t pt = pthread_self();
        
    if (pthread_getcpuclockid(pt, &cid))
        perror("getcpuclockid failed");
        
    pclock("the clock is", cid);
    return 0;
}
</pre>

Compile it and run it using this command:

<pre>
$ ct-cake --auto && ./bin/example
</pre>
which will produce output similar to 
<pre>
make -s -j 3 -f /home/geoff/tmp/bin/gcc.debug/Makefile build
... /home/geoff/tmp/example.cpp
... /home/geoff/tmp/bin/gcc.debug/example
bin/example
the clock is   0.001
</pre>

<p>
What occured was ct-cake searched all the files to find a source file containing the word "main".
It then searched the source file to extract the link flags that are annotated in the source code, so it 
wasn't necessary to supply them at the command-line. compiletools is based on the principle that 
the source code and the build settings are kept together.  This will increase the likelihood of 
keeping the compile flags in sync with the header includes. 
A Makefile was created that expressed the required build and then make was called. Finally the execuatable
was executed.
</p>


<h2>Overview</h2>

<p>
The compiletools project provides a variety of tools for building C/C++ projects and for exploring 
code dependencies. ct-cake is the Swiss army knife of build tools that combines many of the 
compiletools into one uber-tool. For many C/C++ projects you can compile simply using
<pre>
ct-cake --auto
</pre>
The --auto flag tells ct-cake to search for files that will be the "main" file.  
From that set of files, ct-cake then uses the header includes to
determine what implementation (cpp) files are also required to be built and linked 
into the final executable/s.
</p>

<p>

Cake works off the same principles as Ruby on Rails. It will make your life
easy if you don't arbitrarily name things. The main rules are:

</p>
<p>

<ol>
   <li>ct-cake only builds C and C++. Everything can be done just fine with
   other tools, so there's no point reinventing them. Anyway, it's easy to
   embed cake into other toolchains, see the last section.</li>

   <li>All binaries end up in the bin directory, with the same base name as
   their source filename. You can override this at the command-line, but it's
   against the spirit of the tool.</li>

   <li>The implementation file for point.hpp should be called point.cpp. This
   is so ct-cake can compile it and recursively hunt down its dependencies.</li>

   <li>If a header or implementation file will not work without being linked
   with a certain flag, add a //#LDFLAGS=myflag directly to the source code.</li>

   <li>Likewise, if a special compiler option is needed, use //#CXXFLAGS=myflag.</li>

   <li>Minimise the use of "-I" include flags. They make it hard not only
   for cake to generate dependencies, but also autocomplete tools like Eclipse and
   ctags. You can avoid -I flags by structuring your code in the same way you
   refer to paths in your source code. 
   </li>

   <li>Currently only varieties of Linux are actively supported because that's
   what the compiletools developers have easy access to. That said, it stands
   a good chance of working on *BSD and macOS. We are interested in receiving
   patches for other platforms including Windows.
   </li>
</ol>

</p>
<p>
ct-cake works off a "pull" philosophy of building, unlike the "push" model
of most build processes. Often, there is the monolithic build script that
rebuilds everything. Users iterate over changing a file, relinking everything
and then rerunning their binary. A hierarchy of libraries is built up and
then linked in to the final executables. All of this takes a lot of time,
particularly for C++.

</p>
<p>

With ct-cake, you only pull in what is strictly necessary to what you need to run
right now. Say, you are testing a particular tool in a large project, with
a large base of 2000 library files for string handling, sockets, etc. There
is simply no make file. You might want to create a build.sh for regression
testing, but it's not essential.

</p>
<p>

The basic workflow is to simply type:
<pre>
ct-cake --auto
</pre>
If there are multiple executables that --auto finds and you only want to build one specific one:
<pre>
   ct-cake path/to/src/app.cpp
</pre>

</p>
<p>

Only the library cpp files that are needed, directly, or indictly to create
./bin/app are actually compiled. If you don't #include anything that refers
to a library file, you don't pay for it. Also, only the link options that
are strictly needed to generate the app are included. Its possible to do in
make files, but such fine-level granularity is rarely set up in practice,
because its too error-prone to do manually, or with recursive make goodness.

</p>

<h2>How it Works</h2>

<p>
Cake uses "gcc -MM -MF" to generate the header dependencies for the main.cpp
file you specify at the command line. For each header file, it looks for
an underlying implementation (cpp) file with the same name, and adds it to
the build. Cake also reads the first 4k of each file for special comments
that indicate needed link and compile flags.  Cake recurses through the
dependencies of the cpp file, and uses this spidering to generate complete
dependency information for the application. It then lazily generates a
makefile, and finally calls make.

</p>

<h2>Magic Comments</h2>

<p>

Cake works very differently to other build systems, which specify a hierarchy
of link flags and compile options, because cake ties the compiler flags
directly to the source code. If you have compress.hpp that requires "-lzip"
on the link line, add the following comment in the first 4K of the header file:

<pre>
    //#LDFLAGS=-lzip
</pre>

</p>
<p>

Whenever the header is included (either directly or indirectly), the -lzip
will be automatically added to the link step. If you stop using the header,
for a particular executable, cake will figure that out and not link against it.

</p>
<p>

If you want to compile a cpp file with a particular optimization enabled,
add, say:

<pre>
    //#CXXFLAGS=-fstrict-aliasing
</pre>

Because the code and build flags are defined so close to each other, its
much easier to tweak the compilation locally.

</p>

<h2>Performance</h2>

<p>
Because ct-cake internally generates a makefile to build the C++ file, cake is
about as fast as a handrolled Makefile that uses the same lazily generated
dependencies. A typical project takes 0.04 seconds to build if nothing is
out of date, versus 2 seconds for, say, Boost.Build.

</p>
<p>

ct-cake also eliminates the redundant generation of static archive files that
a more hierarchical build process would generate as intermediaries, saving
the cost of running 'ar'.

</p>
<p>
Note that ct-cake doesn't build all cpp files that you have checked out, only those
strictly needed to build your particular binary, so you only pay for what
you use. This difference alone should see a large improvement on most
projects, especially for incremental rebuilds.

</p>


<h2>Cake configuration</h2>

<p>
Cake requires <i>almost</i> no configuration. However, it is still
useful to have some shortcut build templates such as 'release',
'profile' etc.
</p>

<p>
To configure these, cake looks for the following, in order of increasing precedence:

<ul>
    <li>/etc/cake.conf</li>
    <li>CAKE_* variables</li>
    <li>command line options to cake</li>
</ul>

An example /etc/cake.conf file looks as follows:

<pre>
CAKE_CC="g++ -I ."
CAKE_CXXFLAGS="-fPIC -g -Wall"
CAKE_LINKFLAGS="-fPIC -Wall -Werror"
CAKE_TESTPREFIX="valgrind --quiet --error-exitcode=1"
CAKE_POSTPREFIX=""
</pre>

<p>
CAKE_CC must be set to a value that can be used to run <tt>gcc -MM -MF</tt> over the
input source files to generate dependencies. If you have more complex dependencies, you
will need to configure these per-project, and run cake through a script, which is
against the spirit of things.
</p>

<p>
CAKE_CXXFLAGS lists the flags appended to each compilation job. The value in /etc/cake
is completely overridden by the environment variable, which is completely overridden by
the command-line argument --CXXFLAGS=. Likewise, CAKE_LINKFLAGS sets the default options used
for linking.
</p>

<p>
CAKE_TESTPREFIX specifies a command prefix to place in front of unit test runs. This should
ideally be a tool like valgrind, gdb or purify that can be configured to execute the app and
return a non-zero exit code on any failure.
</p>

<p>
CAKE_POSTPREFIX specifies a command prefix to place in front of post-build scripts. This could
be a command that fails after a certain timeout has elapsed, to prevent any locked-up regressions
from blocking the entire build.
</p>

<h2>Build variants</h2>

Cake build variants are used by specifying the variant name at the command-line as follows:

<pre>
    $ cake --variant=release a.cpp && ./bin/a
</pre>

<p>
To configure a variant, create environment variables called CAKE_MYVARIANT_CC,
CAKE_MYVARIANT_CXXFLAGS and CAKE_MYVARIANT_LINKFLAGS. You can also specify them in /etc/cake.
</p>

<p>
The new build variant can then be used by using the name in all lowercase:

<pre>
    $ cake --variant=myvariant a.cpp && ./bin/a
</pre>
</p>

This technique is the recommended way to change the meaning of variants such as release, debug
and profile.

<h2>Unit Tests</h2>

<p>
Cake integrates with unit tests in a fairly simple (and perhaps simplistic) way.
</p>

Cake allows you to specify multiple build targets on each line,
so the following is valid and useful:

<pre>
     $ cake utilities/*.cpp    # builds all apps and places them under bin/
</pre>

Unit tests are executables that are generated, that create an additional
build step. They must run and return an exit code of 0 as part of the build
process. To specify that executables are unit tests, put them in a --begintests/
--endtests block:

<pre>
     $ cake utilities/*.cpp --begintests tests/*.cpp --endtests
</pre>

If any of the tests fail, the build fails. You can also omit the --endtests for
faster typing:

<pre>
     $ cake --begintests tests/*.cpp
</pre>

If the <tt>CAKE_TESTPREFIX</tt> variable is set, you can automatically check
all unit tests with a code purifying tool. For example:

<pre>
export CAKE_TESTPREFIX="valgrind --quiet --error-exitcode=1"
</pre>

will cause all unit tests to only pass if they run through valgrind with no
memory errors.


<h2>Post-Build Steps</h2>

<p>
You may have a number of steps that should be performed after every
successful build. The post-build tests will only run after every binary has been
produced, and every unit test has passed. They only run whenever a dependency
of one of the targets has been touched.
</p>
<p>
Post-build steps are typically shell scripts that test out command-line utilities, 
or tarball up code so it can be uploaded somewhere, etc. Cake does not try to
compile them, which is why a different keyword is needed to distinguish them
from unit tests.
</p>

Post steps are specified like this:

<pre>
     $ cake apps/*.cpp --beginpost ./regression-suite.sh ./generate-tarball.sh --endpost
</pre>

As you might infer from the example, post steps run strictly in the order specified
on the command-line, so that a tarball is only generated if the regression suite passes.


<h2>Putting it all together - a typical build setup</h2>

<p>
For most simple projects, a build.sh script that looks like the
following is quite useful. You can simply add more cpp to 
the apps directory to generate more tools from the project,
or add test scripts to the regression directory to improve
test coverage.
</p>

<p>
Code generation steps can be added at the beginning of
the build.sh, before cake runs.
</p>

<pre>
#!/bin/bash

set -e

cake apps/*.cpp \
    --begintests tests/*.cpp --endtests \
    --beginpost regression/test*.sh --endpost \
    "$@"

</pre>

<p>The special <tt>"$@"</tt> marker is the recommended way
of forwarding arguments to an application. You can then
run the build script like this:</p>

<pre>
    $ ./build.sh --variant=release
</pre>

or:

<pre>
    $ ./build.sh --variant=release --append-CXXFLAGS=-DSPECIALMODE
</pre>


</div>
  
</body>
</html>
