#! /usr/bin/env python
# vim: set filetype=python:
from __future__ import print_function
from __future__ import unicode_literals

import sys
from io import open

import configargparse

import ct.utils
import ct.wrappedos
from ct.hunter import Hunter


class CMakefileCreator:

    """ Create a CMakefile.txt based on the filename, --static and --dynamic command line options """

    def __init__(self, argv=None):
        self.namer = ct.utils.Namer(argv)
        self.hunter = Hunter(argv)

        self.args = None
        # self.args will exist after this call
        ct.utils.setattr_args(self, argv)

    @staticmethod
    def add_arguments(cap, variant, argv=None):
        ct.utils.add_target_arguments(parser)
        ct.utils.add_link_arguments(parser)
        ct.utils.add_output_directory_arguments(parser, variant)
        ct.utils.Namer.add_arguments(parser, variant, argv)
        ct.utils.Hunter.add_arguments(argv)

    def create(self):
        with open("CMakeLists.txt", mode='w', encoding='utf-8') as cmf:
            cmf.write("# CMakeLists.txt generated by ct-create-cmakelists\n")
            cmf.write("cmake_minimum_required (VERSION 2.8)\n\n")
            # TODO: Set "project" to be the name of the cwd
            cmf.write("project (CompileTools)\n")

            cmf.write(
                ''.join(['set(CMAKE_CXX_COMPILER "', self.args.CXX, '")\n']))
            cmf.write(
                ''.join(
                    [
                        'set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ',
                        self.args.CXXFLAGS.replace(
                            '\\',
                            '\\\\\\'),
                        '")\n\n']))

            cmf.write("include_directories(\n    ")
            cmf.write("\n    ".join(self.args.include))
            cmf.write("\n)\n")

            for source_filename in self.args.filename:
                src_realpath = ct.wrappedos.realpath(source_filename)
                complete_sources = self.hunter.required_source_files(
                    src_realpath)
                exe_name = self.namer.executable_name(src_realpath)
                exe_source_files_cmake_name = exe_name.upper() + \
                    "_SOURCE_FILES"
                cmf.write("\nset(" + exe_source_files_cmake_name + "\n    ")
                cmf.write("\n    ".join(list(complete_sources)))
                cmf.write("\n)\n\n")
                cmf.write("".join(
                    ["add_executable(", exe_name, " ${", exe_source_files_cmake_name, "})\n\n"]))
                cmf.write(
                    " ".join(
                        [
                            "target_include_directories(",
                            exe_name,
                            "PUBLIC",
                            ct.wrappedos.dirname(src_realpath),
                            ")\n"]))

                cmf.write(" ".join(["install (TARGETS",
                                    exe_name,
                                    "DESTINATION",
                                    self.namer.executable_dir(src_realpath),
                                    ")\n\n"]))


def main(argv=None):
    if argv is None:
        argv = sys.argv
    variant = ct.utils.extract_variant_from_argv(argv)
    config_files = ct.utils.config_files_from_variant()
    cap = configargparse.getArgumentParser(
        description='Create a CMakefile.txt that will compile the given source file into an executable (or library). Each given file is assumed to be compiled into a separate executable and/or library.',
        formatter_class=configargparse.DefaultsRawFormatter,
        default_config_files=config_files)
    cap.add(
        "-c",
        "--config",
        is_config_file=True,
        help="Manually specify the config file path if you want to override the variant default")

    CMakefileCreator.add_arguments(cap, variant, argv)
    args = ct.utils.parseargs(cap, argv)
    cmakefile_creator = CMakefileCreator(args)
    cmakefile_creator.create()


if __name__ == '__main__':
    main()
