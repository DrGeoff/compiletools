#! /usr/bin/env python
# vim: set filetype=python:
from __future__ import print_function
import configargparse
import ct.utils as utils
from ct.hunter import Hunter

class CMakefileCreator:

    """ Create a CMakefile.txt based on the filename, --static and --dynamic command line options """

    def __init__(self,cap,variant):
        self.namer = utils.Namer(cap, variant)
        utils.add_target_arguments(cap)
        utils.add_link_arguments(cap)
        self.hunter = Hunter()

        # self.args will exist after this call
        utils.setattr_args(self)

    def create(self):
        with open("CMakeLists.txt", mode='w+') as cmf:
            cmf.write("# CMakeLists.txt generated by ct-create-cmakelists\n")
            cmf.write("cmake_minimum_required (VERSION 2.8)\n\n")
            # TODO: Set "project" to be the name of the cwd
            cmf.write("project (CompileTools)\n")
            
            cmf.write(''.join(['set(CMAKE_CXX_COMPILER "',self.args.CXX,'")\n']))
            cmf.write(''.join(['set(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS}"',self.args.CXXFLAGS,'")\n']))

            cmf.write("include_directories(")
            for inc in self.args.include:
                cmf.write(inc)
            cmf.write(")\n")

            for source_filename in self.args.filename:
                src_realpath = utils.realpath(source_filename)
                complete_sources = self.hunter.required_source_files(src_realpath)
                exe_name = self.namer.executable_name(src_realpath)
                exe_source_files_cmake_name = "".join([exe_name,"_source_files"])
                cmf.write(" ".join(["set(",exe_source_files_cmake_name]+list(complete_sources)+[")\n"]))
                cmf.write("".join(["add_executable(",exe_name," ${",exe_source_files_cmake_name,"})\n"]))
                cmf.write(" ".join(["target_include_directories(",exe_name,"PUBLIC", utils.dirname(src_realpath),")\n"]))

                cmf.write(" ".join(["install (TARGETS",exe_name,"DESTINATION",self.namer.executable_dir(src_realpath),")\n\n"]))

if __name__ == '__main__':
    variant = utils.extract_variant_from_argv()
    config_files = utils.config_files_from_variant()
    cap = configargparse.getArgumentParser(
        description='Create a CMakefile.txt that will compile the given source file into an executable (or library). Each given file is assumed to be compiled into a separate executable and/or library.',
        formatter_class=configargparse.DefaultsRawFormatter,
        default_config_files=config_files)
    cap.add(
        "-c",
        "--config",
        is_config_file=True,
        help="Manually specify the config file path if you want to override the variant default")

    cmakefile_creator = CMakefileCreator(cap,variant)
    myargs = cap.parse_known_args()
    utils.verbose_print_args(myargs[0])

    cmakefile_creator.create()
