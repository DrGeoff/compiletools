#!/usr/bin/env python3
"""Profile ct-compilation-database performance on an arbitrary directory.

Usage:
    scripts/profile-ct-compilation-database --directory /path/to/project
    scripts/profile-ct-compilation-database --directory /path/to/project --profile-output project.prof
"""
import argparse
import cProfile
import pstats
import tempfile
import time
import os
import sys
from pathlib import Path


def extract_performance_metrics(ps: pstats.Stats) -> dict:
    """Extract key performance metrics from pstats."""
    total_calls = ps.total_calls
    total_time = ps.total_tt

    # Get top functions by cumulative time
    top_functions = []
    compiletools_functions = {}

    for func, (cc, nc, tt, ct, callers) in ps.stats.items():
        if ct > 0.001:  # Only include functions with significant time
            filename, lineno, funcname = func
            if filename.startswith('/'):
                filename = filename.split('/')[-1]
            func_name = f"{filename}:{lineno}({funcname})"

            func_data = {
                'ncalls': f"{cc}/{nc}" if cc != nc else str(nc),
                'tottime': tt,
                'cumtime': ct,
                'function': func_name
            }
            top_functions.append(func_data)

            if 'compiletools' in str(func[0]):
                key = func_name
                compiletools_functions[key] = {
                    'ncalls': func_data['ncalls'],
                    'tottime': func_data['tottime'],
                    'cumtime': func_data['cumtime']
                }

    # Sort by cumulative time
    top_functions.sort(key=lambda x: x['cumtime'], reverse=True)

    return {
        'total_calls': total_calls,
        'total_time': total_time,
        'top_functions': top_functions[:20],
        'compiletools_functions': compiletools_functions
    }


def print_metrics(metrics: dict, wall_time: float) -> None:
    """Print performance metrics in a readable format."""
    print("\n" + "=" * 80)
    print("PERFORMANCE SUMMARY")
    print("=" * 80)
    print(f"Wall-clock time: {wall_time:.3f}s")
    print(f"CPU time: {metrics['total_time']:.3f}s")
    print(f"Total function calls: {metrics['total_calls']:,}")

    print("\n" + "-" * 80)
    print("TOP 20 FUNCTIONS BY CUMULATIVE TIME")
    print("-" * 80)
    print(f"{'Function':<55} {'Calls':<12} {'CumTime':<10}")
    print("-" * 80)

    for func in metrics['top_functions']:
        display_name = func['function'][:52] + "..." if len(func['function']) > 55 else func['function']
        print(f"{display_name:<55} {func['ncalls']:<12} {func['cumtime']:.3f}s")

    # Show compiletools-specific functions sorted by cumtime
    ct_funcs = sorted(
        metrics['compiletools_functions'].items(),
        key=lambda x: x[1]['cumtime'],
        reverse=True
    )[:15]

    if ct_funcs:
        print("\n" + "-" * 80)
        print("TOP COMPILETOOLS FUNCTIONS")
        print("-" * 80)
        print(f"{'Function':<55} {'Calls':<12} {'CumTime':<10}")
        print("-" * 80)

        for func_name, data in ct_funcs:
            display_name = func_name[:52] + "..." if len(func_name) > 55 else func_name
            print(f"{display_name:<55} {data['ncalls']:<12} {data['cumtime']:.3f}s")


def run_profiling(directory: str, profile_output: str = None, verbose: int = 0) -> dict:
    """Run ct-compilation-database under cProfile.

    Args:
        directory: Directory to run ct-compilation-database in
        profile_output: Optional path to save .prof file
        verbose: Verbosity level for ct-compilation-database

    Returns:
        dict with performance metrics
    """
    # Add src to path for imports
    src_path = Path(__file__).parent.parent / "src"
    sys.path.insert(0, str(src_path))

    from compiletools import compilation_database

    # Create temp directory for output to avoid polluting target project
    with tempfile.TemporaryDirectory() as tmpdir:
        output_file = os.path.join(tmpdir, "compile_commands.json")

        # Build argv for ct-compilation-database
        argv = [
            "--auto",
            "--compilation-database-output", output_file,
        ]
        if verbose:
            argv.extend(["--verbose"] * verbose)

        # Change to target directory
        original_cwd = os.getcwd()
        os.chdir(directory)

        try:
            # Profile the execution
            profiler = cProfile.Profile()

            start_time = time.perf_counter()
            profiler.enable()

            compilation_database.main(argv)

            profiler.disable()
            end_time = time.perf_counter()

            wall_time = end_time - start_time

            # Save profile if requested
            if profile_output:
                profiler.dump_stats(profile_output)
                print(f"Profile saved to: {profile_output}")

            # Extract and return metrics
            ps = pstats.Stats(profiler)
            ps.sort_stats('cumulative')
            metrics = extract_performance_metrics(ps)

            return metrics, wall_time

        finally:
            os.chdir(original_cwd)


def main():
    parser = argparse.ArgumentParser(
        description="Profile ct-compilation-database performance",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        "--directory", "-d",
        default=".",
        help="Directory to run ct-compilation-database in"
    )
    parser.add_argument(
        "--profile-output", "-o",
        help="Save profile data to this file for detailed analysis"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="count",
        default=0,
        help="Increase verbosity (can be repeated)"
    )

    args = parser.parse_args()

    directory = os.path.abspath(args.directory)
    if not os.path.isdir(directory):
        print(f"Error: {directory} is not a directory")
        return 1

    print(f"Profiling ct-compilation-database in: {directory}")

    metrics, wall_time = run_profiling(
        directory,
        profile_output=args.profile_output,
        verbose=args.verbose
    )

    print_metrics(metrics, wall_time)

    return 0


if __name__ == "__main__":
    sys.exit(main())
