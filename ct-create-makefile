#! /usr/bin/env python
# vim: set filetype=python:
from __future__ import print_function
import os.path
import configargparse
import utils
import git_utils
from memoize import memoize
from hunter import HeaderDependencies
from hunter import Hunter


class Rule:

    """ A rule is a target, prerequisites and optionally a recipe
        https://www.gnu.org/software/make/manual/html_node/Rule-Introduction.html#Rule-Introduction
        Example: myrule = Rule(target='mytarget' prerequisites='file1.hpp file2.hpp', recipe='g++ -c mytarget.cpp -o mytarget.o')
        Note: it had to be a class rather than a dict so that we could hash it.
    """

    def __init__(self, target, prerequisites, recipe=None, phony=False):
        self.target = target
        self.prerequisites = prerequisites
        self.recipe = recipe
        self.phony = phony

    def __repr__(self):
        return "%s(%r)" % (self.__class__, self.__dict__)

    def __str__(self):
        return "%r" % (self.__dict__)

    def __eq__(self, other):
        return self.target == other.target

    def __hash__(self):
        return hash(self.target)

    def write(self, makefile):
        """ Write the given rule into the given Makefile."""
        if self.phony:
            makefile.write(" ".join([".PHONY:", self.target, "\n"]))

        makefile.write(self.target + ": " + self.prerequisites + "\n")
        try:
            makefile.write("\t" + self.recipe + "\n")
        except:
            pass
        makefile.write("\n")


class MakefileCreator:

    """ Create a Makefile based on the filename, --static and --dynamic command line options """

    def __init__(self, cap, variant):
        utils.add_target_arguments(cap, variant)
        utils.add_link_arguments(cap)
        # self.args will exist after this call
        utils.setattr_args(self)
        self.hunter = Hunter()

    @memoize
    def object_dir(self, source_filename):
        """ Put objects into a directory structure that starts with the command line objdir
            but then replicates the project directory structure.  This way we can separate 
            object files that have the same name but different paths
        """
        project_pathname = git_utils.strip_git_root(source_filename)
        return "".join([self.args.objdir, "/", utils.dirname(project_pathname)])

    @memoize
    def object_name(self, source_filename):
        """ Return the name (not the path) of the object file for the given source """
        name = os.path.split(source_filename)[1]
        basename = os.path.splitext(name)[0]
        return "".join([basename, ".o"])

    @memoize
    def object_pathname(self, source_filename):
        return "".join([self.object_dir(source_filename), "/", self.object_name(source_filename)])

    @memoize
    def executable_dir(self, source_filename):
        """ Put the binaries into a directory structure that starts with the command line bindir
            but then replicates the project directory structure.  This way we can separate 
            executable files that have the same name but different paths
        """
        project_pathname = git_utils.strip_git_root(source_filename)
        return "".join([self.args.bindir, "/", utils.dirname(project_pathname)])
        
    @memoize
    def executable_name(self, source_filename):
        name = os.path.split(source_filename)[1]
        return os.path.splitext(name)[0]

    @memoize
    def executable_pathname(self, source_filename):
        return "".join([self.executable_dir(source_filename), "/", self.executable_name(source_filename)])

    def create(self):
        # Find the realpaths of the given filenames (to avoid this being duplicated many times)
        realpath_sources = map(utils.realpath, self.args.filename)

        # Keep track of what build artifacts are created for easier cleanup
        self.objects = set()
        self.object_directories = set()
        all_exes_dirs = [str(exe_dir) for exe_dir in map(self.executable_dir,realpath_sources)]
        all_exes = [str(exe) for exe in map(self.executable_pathname,realpath_sources)]

        # By using a set, duplicate rules will be eliminated.
        self.rules = utils.OrderedSet()
        rule_all = Rule(
            target="all",
            prerequisites=" ".join(["mkdir_output"] + all_exes),
            phony=True)
        self.rules.add(rule_all)

        for realpath_source in realpath_sources:
            self.rules = self.rules | self._create_makefile_rules_for_source(realpath_source)

        rule_mkdir_output = Rule(
            target="mkdir_output",
            prerequisites="",
            recipe=" ".join(["mkdir -p"] + all_exes_dirs + list(self.object_directories)),
            phony=True)
        self.rules.add(rule_mkdir_output)
   
        # Use a "./" in front of files/directories to be removed to avoid any nasy surprises by files beginning with "-"
        safe_rm_objdir = ["find","./"+self.args.objdir,"-type d -empty -delete"]
        safe_rm_bindir = ["find","./"+self.args.bindir,"-type d -empty -delete"]
        rule_clean = Rule(
            target="clean",
            prerequisites="",
            recipe=" ".join(["rm -f"] + all_exes + list(self.objects) + [";"] + safe_rm_objdir +  [";"] + safe_rm_bindir ),
            phony=True)
        self.rules.add(rule_clean)

        rule_realclean = Rule(
            target="realclean",
            prerequisites="",
            recipe=" ".join(["rm -rf", self.args.bindir, "; rm -rf", self.args.objdir]),
            phony=True)
        self.rules.add(rule_realclean)

        self.write()

    def _create_compile_rule_for_source(self, source):
        """ For a given source file return the compile rule required for the Makefile """
        deplist = self.hunter.header_dependencies(source)
        self.object_directories.add( self.object_dir(source) )
        obj_name = self.object_pathname(source)
        self.objects.add( obj_name )
        magic_cxx_flags = self.hunter.magic()[source].get('CXXFLAGS', [])
        return Rule(target=obj_name,
                    prerequisites=" ".join([source] + [str(dep) for dep in deplist]),
                    recipe=" ".join([self.args.CXX,
                                     self.args.CXXFLAGS] + list(magic_cxx_flags) + ["-c",
                                                                                    "-o",
                                                                                    obj_name,
                                                                                    source]))

    def _create_link_rule(self, source_filename, complete_sources):
        """ For a given source file (so usually the file with the main) and the set of complete sources (i.e., all the other source files + the original) return the link rule required for the Makefile """

        exe_name = self.executable_pathname(utils.realpath(source_filename))
        object_names = " ".join(
            str(obj) for obj in map(
                self.object_pathname,
                complete_sources))

        all_magic_ldflags = set()
        for sf in complete_sources:
            magic_flags = self.hunter.magic()[sf]
            all_magic_ldflags |= magic_flags.get('LDFLAGS', set())
            all_magic_ldflags |= magic_flags.get(
                'LINKFLAGS',
                set())  # For backward compatibility with cake

        return Rule(target=exe_name,
                    prerequisites=object_names,
                    recipe=" ".join([self.args.LD,
                                     self.args.LDFLAGS] + list(all_magic_ldflags) + ["-o",
                                                                                     exe_name,
                                                                                     object_names]))

    def _create_makefile_rules_for_source(self, source):
        """ For a given source file return the set of rules required for the Makefile """

        # Reset the cycle detection because we are starting a new source file
        cycle_detection = set()

        # The set of rules needed to turn the source file into an executable
        # (or library as appropriate)
        rules_for_source = utils.OrderedSet()

        complete_sources = self.hunter.required_source_files(source)
        if self.args.verbose >= 6:
            print(
                "Complete list of implied source files for " +
                source +
                ": " +
                " ".join(
                    cs for cs in complete_sources))
        rules_for_source.add(self._create_link_rule(source, complete_sources))

        for item in complete_sources:
            if item not in cycle_detection:
                cycle_detection.add(item)
                rules_for_source.add(
                    self._create_compile_rule_for_source(item))

        return rules_for_source

    def write(self, makefile_name='Makefile'):
        """ Take a list of rules and write the rules to a Makefile """
        with open(makefile_name, mode='w+') as mf:
            mf.write("# Makefile generated by ct-create-makefile\n")
            for rule in self.rules:
                rule.write(mf)

if __name__ == '__main__':
    variant = utils.extract_variant_from_argv()
    config_files = utils.config_files_from_variant()
    cap = configargparse.getArgumentParser(
        description='Create a Makefile that will compile the given source file into an executable (or library). Each given file is assumed to be compiled into a separate executable and/or library.',
        formatter_class=configargparse.DefaultsRawFormatter,
        default_config_files=config_files)

    # The config file has to be added here.  For some reason doing it in the
    # utils.add_common_arguments fails.
    cap.add(
        "-c",
        "--config",
        is_config_file=True,
        help="Manually specify the config file path if you want to override the variant default")
    makefile_creator = MakefileCreator(cap, variant)

    myargs = cap.parse_known_args()
    utils.verbose_print_args(myargs[0])

    makefile_creator.create()
