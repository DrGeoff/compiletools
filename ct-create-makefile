#! /usr/bin/env python
# vim: set filetype=python:
from __future__ import print_function
import os.path
import configargparse
import utils
from hunter import HeaderDependencies
from hunter import Hunter


class Rule:

    """ A rule is a target, prerequisites and optionally a recipe
        https://www.gnu.org/software/make/manual/html_node/Rule-Introduction.html#Rule-Introduction
        Example: myrule = Rule(target='mytarget' prerequisites='file1.hpp file2.hpp', recipe='g++ -c mytarget.cpp -o mytarget.o')
        Note: it had to be a class rather than a dict so that we could hash it.
    """

    def __init__(self, target, prerequisites, recipe=None):
        self.target = target
        self.prerequisites = prerequisites
        self.recipe = recipe

    def __repr__(self):
        return "%s(%r)" % (self.__class__, self.__dict__)

    def __str__(self):
        return "%r" % (self.__dict__)

    def __eq__(self, other):
        return self.target == other.target

    def __hash__(self):
        return hash(self.target)

    def write(self, makefile):
        """ Write the given rule into the given Makefile."""
        makefile.write(self.target + ": " + self.prerequisites + "\n")
        try:
            makefile.write("\t" + self.recipe + "\n")
        except:
            pass
        makefile.write("\n")


def executable_name(source_filename):
    # TODO: Stop assuming exe files go into "bin"
    name = os.path.split(source_filename)[1]
    basename = os.path.splitext(source_filename)[0]
    return os.path.join("bin/", basename)


def object_name(source_filename):
    name = os.path.split(source_filename)[1]
    basename = os.path.splitext(name)[0]
    # TODO: Stop assuming object files go into "bin"
    return os.path.join("bin/", basename + ".o")


class MakefileCreator:

    """ Create a Makefile based on the filename, --static and --dynamic command line options """

    def __init__(self):
        cap = configargparse.getArgumentParser()
        cap.add(
            "--LD",
            help="Linker",
            default="unsupplied_implies_use_CXX")
        cap.add(
            "--LDFLAGS",
            help="Linker flags",
            default="unsupplied_implies_use_CXXFLAGS")
        self.header_dependencies = HeaderDependencies()

        # self.args will exist after this call
        utils.setattr_args(self)

    def create(self):
        # By using a set, duplicate rules will be eliminated.
        self.rules = utils.OrderedSet()
        rule_all = Rule(
            "all",
            " ".join(
                str(exe) for exe in map(
                    executable_name,
                    self.args.filename)))
        self.rules.add(rule_all)

        for source in self.args.filename:
            self.rules = self.rules | self._create_makefile_rules_for_source(
                source)

        self.write()

    def _create_compile_rule_for_source(self, source):
        """ For a given source file return the compile rule required for the Makefile """

        deplist = self.header_dependencies.process(source)
        obj_name = object_name(source)
        return Rule(
            target=obj_name,
            prerequisites=source + " " +
            " ".join(
                str(dep) for dep in deplist),
            recipe=self.args.CXX +
            " " +
            self.args.CXXFLAGS +
            " -c -o " +
            obj_name +
            " " +
            source)

    def _create_link_rule(self, source_filename, complete_sources):
        """ For a given source file (so usually the file with the main) and the set of complete sources (i.e., all the other source files + the original) return the link rule required for the Makefile """

        exe_name = executable_name(source_filename)
        object_names = " ".join(
            str(obj) for obj in map(
                object_name,
                complete_sources))

        return Rule(
            target=exe_name,
            prerequisites=object_names,
            recipe=self.args.LD +
            " " +
            self.args.LDFLAGS +
            " -o " +
            exe_name +
            " " +
            object_names)

    def _create_makefile_rules_for_source(self, source):
        """ For a given source file return the set of rules required for the Makefile """

        # The set of rules needed to turn the source file into an executable
        # (or library as appropriate)
        rules_for_source = utils.OrderedSet()

        hunter = Hunter()
        complete_sources = hunter.process(source)
        if self.args.verbose >= 6:
            print(
                "Complete list of implied source files for " +
                source +
                ": " +
                " ".join(
                    cs for cs in complete_sources))
        rules_for_source.add(self._create_link_rule(source, complete_sources))

        for item in complete_sources:
            rules_for_source.add(self._create_compile_rule_for_source(item))

        return rules_for_source

    def write(self, makefile_name='Makefile'):
        """ Take a list of rules and write the rules to a Makefile """
        with open(makefile_name, mode='w+') as mf:
            mf.write("# Makefile generated by ct-create-makefile\n")
            for rule in self.rules:
                rule.write(mf)

if __name__ == '__main__':
    cap = configargparse.getArgumentParser(
        description='Create a Makefile that will compile the given source file into an executable (or library). Each given file is assumed to be compiled into a separate executable and/or library.',
        formatter_class=configargparse.DefaultsRawFormatter)
    cap.add("-c", "--config", is_config_file=True, help="config file path")
    cap.add("filename", nargs='*', help="File to compile to an executable")
    cap.add(
        "--dynamic",
        nargs='*',
        help="File to compile to an dynamic library")
    cap.add(
        "--static",
        nargs='*',
        help="File to compile to an dynamic library")

    makefile_creator = MakefileCreator()

    myargs = cap.parse_known_args()

    if myargs[0].verbose >= 1:
        print(myargs[0])
    if myargs[0].verbose >= 2:
        cap.print_values()

    makefile_creator.create()
