#! /usr/bin/env python
# vim: set filetype=python:
from __future__ import print_function
import os.path
import configargparse
import utils
from memoize import memoize
from hunter import HeaderDependencies
from hunter import Hunter


class Rule:

    """ A rule is a target, prerequisites and optionally a recipe
        https://www.gnu.org/software/make/manual/html_node/Rule-Introduction.html#Rule-Introduction
        Example: myrule = Rule(target='mytarget' prerequisites='file1.hpp file2.hpp', recipe='g++ -c mytarget.cpp -o mytarget.o')
        Note: it had to be a class rather than a dict so that we could hash it.
    """

    def __init__(self, target, prerequisites, recipe=None, phony=False):
        self.target = target
        self.prerequisites = prerequisites
        self.recipe = recipe
        self.phony = phony

    def __repr__(self):
        return "%s(%r)" % (self.__class__, self.__dict__)

    def __str__(self):
        return "%r" % (self.__dict__)

    def __eq__(self, other):
        return self.target == other.target

    def __hash__(self):
        return hash(self.target)

    def write(self, makefile):
        """ Write the given rule into the given Makefile."""
        if self.phony:
            makefile.write(" ".join([".PHONY:", self.target, "\n"]))

        makefile.write(self.target + ": " + self.prerequisites + "\n")
        try:
            makefile.write("\t" + self.recipe + "\n")
        except:
            pass
        makefile.write("\n")


class MakefileCreator:

    """ Create a Makefile based on the filename, --static and --dynamic command line options """

    def __init__(self, cap, variant):
        utils.add_target_arguments(cap, variant)
        utils.add_link_arguments(cap)
        # self.args will exist after this call
        utils.setattr_args(self)
        self.hunter = Hunter()

    @memoize
    def object_name(self, source_filename):
        name = os.path.split(source_filename)[1]
        basename = os.path.splitext(name)[0]
        return "".join([self.args.objdir, "/", basename, ".o"])

    @memoize
    def executable_name(self, source_filename):
        name = os.path.split(source_filename)[1]
        basename = os.path.splitext(name)[0]
        return "".join([self.args.bindir, "/", basename])

    def create(self):
        # By using a set, duplicate rules will be eliminated.
        self.rules = utils.OrderedSet()
        rule_all = Rule(
            target="all",
            prerequisites=" ".join(["mkdir_output"] +
                                   [str(exe) for exe in map(
                                       self.executable_name,
                                       map(utils.realpath, self.args.filename))]),
            phony=True)
        self.rules.add(rule_all)

        rule_mkdir_output = Rule(
            target="mkdir_output",
            prerequisites="",
            recipe=" ".join(["mkdir -p", self.args.bindir, "; mkdir -p", self.args.objdir]),
            phony=True)
        self.rules.add(rule_mkdir_output)

        rule_clean = Rule(
            target="clean",
            prerequisites="",
            recipe=" ".join(["rm -rf", self.args.bindir, "; rm -rf", self.args.objdir]),
            phony=True)
        self.rules.add(rule_clean)

        for source in self.args.filename:
            realpath_source = utils.realpath(source)
            self.rules = self.rules | self._create_makefile_rules_for_source(
                realpath_source)

        self.write()

    def _create_compile_rule_for_source(self, source):
        """ For a given source file return the compile rule required for the Makefile """
        deplist = self.hunter.header_dependencies(source)
        obj_name = self.object_name(source)
        magic_cxx_flags = self.hunter.magic()[source].get('CXXFLAGS', [])
        return Rule(target=obj_name,
                    prerequisites=" ".join([source] + [str(dep) for dep in deplist]),
                    recipe=" ".join([self.args.CXX,
                                     self.args.CXXFLAGS] + list(magic_cxx_flags) + ["-c",
                                                                                    "-o",
                                                                                    obj_name,
                                                                                    source]))

    def _create_link_rule(self, source_filename, complete_sources):
        """ For a given source file (so usually the file with the main) and the set of complete sources (i.e., all the other source files + the original) return the link rule required for the Makefile """

        exe_name = self.executable_name(utils.realpath(source_filename))
        object_names = " ".join(
            str(obj) for obj in map(
                self.object_name,
                complete_sources))

        all_magic_ldflags = set()
        for sf in complete_sources:
            magic_flags = self.hunter.magic()[sf]
            all_magic_ldflags |= magic_flags.get('LDFLAGS', set())
            all_magic_ldflags |= magic_flags.get(
                'LINKFLAGS',
                set())  # For backward compatibility with cake

        return Rule(target=exe_name,
                    prerequisites=object_names,
                    recipe=" ".join([self.args.LD,
                                     self.args.LDFLAGS] + list(all_magic_ldflags) + ["-o",
                                                                                     exe_name,
                                                                                     object_names]))

    def _create_makefile_rules_for_source(self, source):
        """ For a given source file return the set of rules required for the Makefile """

        # Reset the cycle detection because we are starting a new source file
        cycle_detection = set()

        # The set of rules needed to turn the source file into an executable
        # (or library as appropriate)
        rules_for_source = utils.OrderedSet()

        complete_sources = self.hunter.required_source_files(source)
        if self.args.verbose >= 6:
            print(
                "Complete list of implied source files for " +
                source +
                ": " +
                " ".join(
                    cs for cs in complete_sources))
        rules_for_source.add(self._create_link_rule(source, complete_sources))

        for item in complete_sources:
            if item not in cycle_detection:
                cycle_detection.add(item)
                rules_for_source.add(
                    self._create_compile_rule_for_source(item))

        return rules_for_source

    def write(self, makefile_name='Makefile'):
        """ Take a list of rules and write the rules to a Makefile """
        with open(makefile_name, mode='w+') as mf:
            mf.write("# Makefile generated by ct-create-makefile\n")
            for rule in self.rules:
                rule.write(mf)

if __name__ == '__main__':
    variant = utils.extract_variant_from_argv()
    config_files = utils.config_files_from_variant()
    cap = configargparse.getArgumentParser(
        description='Create a Makefile that will compile the given source file into an executable (or library). Each given file is assumed to be compiled into a separate executable and/or library.',
        formatter_class=configargparse.DefaultsRawFormatter,
        default_config_files=config_files)

    # The config file has to be added here.  For some reason doing it in the
    # utils.add_common_arguments fails.
    cap.add(
        "-c",
        "--config",
        is_config_file=True,
        help="Manually specify the config file path if you want to override the variant default")
    makefile_creator = MakefileCreator(cap, variant)

    myargs = cap.parse_known_args()
    utils.verbose_print_args(myargs[0])

    makefile_creator.create()
